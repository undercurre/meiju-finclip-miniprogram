import{BLUE,WHITE}from"../common/color";import{VantComponent}from"../common/component";import{getSystemInfoSync}from"../common/utils";import{isObj}from"../common/validator";import{canIUseCanvas2d}from"../common/version";import{adaptor}from"./canvas";function format(rate){return Math.min(Math.max(rate,0),100)}const PERIMETER=2*Math.PI,BEGIN_ANGLE=-Math.PI/2,STEP=1;VantComponent({props:{text:String,lineCap:{type:String,value:"round"},value:{type:Number,value:0,observer:"reRender"},speed:{type:Number,value:50},size:{type:Number,value:100,observer(){this.drawCircle(this.currentValue)}},fill:String,layerColor:{type:String,value:WHITE},color:{type:null,value:BLUE,observer(){this.setHoverColor().then(()=>{this.drawCircle(this.currentValue)})}},type:{type:String,value:"2d"},strokeWidth:{type:Number,value:4},clockwise:{type:Boolean,value:!0}},data:{hoverColor:BLUE},methods:{getContext(){const{type,size}=this.data;if(type===""||!canIUseCanvas2d()){const ctx=wx.createCanvasContext("van-circle",this);return Promise.resolve(ctx)}const dpr=getSystemInfoSync().pixelRatio;return new Promise(resolve=>{wx.createSelectorQuery().in(this).select("#van-circle").node().exec(res=>{const canvas=res[0].node,ctx=canvas.getContext(type);this.inited||(this.inited=!0,canvas.width=size*dpr,canvas.height=size*dpr,ctx.scale(dpr,dpr)),resolve(adaptor(ctx))})})},setHoverColor(){const{color,size}=this.data;return isObj(color)?this.getContext().then(context=>{const LinearColor=context.createLinearGradient(size,0,0,0);Object.keys(color).sort((a,b)=>parseFloat(a)-parseFloat(b)).map(key=>LinearColor.addColorStop(parseFloat(key)/100,color[key])),this.hoverColor=LinearColor}):(this.hoverColor=color,Promise.resolve())},presetCanvas(context,strokeStyle,beginAngle,endAngle,fill){const{strokeWidth,lineCap,clockwise,size}=this.data,position=size/2,radius=position-strokeWidth/2;context.setStrokeStyle(strokeStyle),context.setLineWidth(strokeWidth),context.setLineCap(lineCap),context.beginPath(),context.arc(position,position,radius,beginAngle,endAngle,!clockwise),context.stroke(),fill&&(context.setFillStyle(fill),context.fill())},renderLayerCircle(context){const{layerColor,fill}=this.data;this.presetCanvas(context,layerColor,0,PERIMETER,fill)},renderHoverCircle(context,formatValue){const{clockwise}=this.data,progress=PERIMETER*(formatValue/100),endAngle=clockwise?BEGIN_ANGLE+progress:3*Math.PI-(BEGIN_ANGLE+progress);this.presetCanvas(context,this.hoverColor,BEGIN_ANGLE,endAngle)},drawCircle(currentValue){const{size}=this.data;this.getContext().then(context=>{context.clearRect(0,0,size,size),this.renderLayerCircle(context);const formatValue=format(currentValue);formatValue!==0&&this.renderHoverCircle(context,formatValue),context.draw()})},reRender(){const{value,speed}=this.data;if(speed<=0||speed>1e3){this.drawCircle(value);return}this.clearMockInterval(),this.currentValue=this.currentValue||0;const run=()=>{this.interval=setTimeout(()=>{this.currentValue!==value?(Math.abs(this.currentValue-value)<STEP?this.currentValue=value:this.currentValue<value?this.currentValue+=STEP:this.currentValue-=STEP,this.drawCircle(this.currentValue),run()):this.clearMockInterval()},1e3/speed)};run()},clearMockInterval(){this.interval&&(clearTimeout(this.interval),this.interval=null)}},mounted(){this.currentValue=this.data.value,this.setHoverColor().then(()=>{this.drawCircle(this.currentValue)})},destroyed(){this.clearMockInterval()}});
